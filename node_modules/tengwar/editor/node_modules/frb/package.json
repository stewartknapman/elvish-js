{
  "name": "frb",
  "version": "0.0.7",
  "description": "Functional reactive bindings",
  "keywords": [
    "functional",
    "reactive",
    "bindings",
    "observe",
    "change"
  ],
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com",
    "url": "http://github.com/kriskowal/"
  },
  "contributors": [
    {
      "name": "Kris Kowal",
      "email": "kris@cixar.com",
      "url": "http://github.com/kriskowal/"
    }
  ],
  "bugs": {
    "mail": "kris@cixar.com",
    "url": "http://github.com/kriskowal/frb/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/kriskowal/frb/raw/master/LICENSE.md"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/kriskowal/frb.git"
  },
  "main": "bindings",
  "dependencies": {
    "collections": ">=0.0.6"
  },
  "devDependencies": {
    "jasmine-node": "1.x.x"
  },
  "scripts": {
    "test": "jasmine-node spec"
  },
  "readme": "\n# Functional Reactive Bindings\n\nIn their simplest form, bindings provide the illusion that two objects\nhave the same property.  Changing the property on one object causes the\nsame change in the other.  This is useful for coordinating state between\nviews and models, among other entangled objects.  For example, if you\nenter text into a text field, the same text might be added to the\ncorresponding database record.\n\n```javascript\nbind(object, \"a.b\", {\"<->\": \"c.d\"});\n```\n\nFunctional Reactive Bindings go farther.  They can gracefully bind long\nproperty paths and the contents of collections.  They can also\nincrementally update the results of chains of queries including maps,\nflattened arrays, sums, and averages.  They can also add and remove\nelements from sets based on the changes to a flag.  FRB makes it easy to\nincrementally ensure consistent state.\n\n```javascript\nbind(company, \"payroll\", {\"<-\": \"departments.map{employees.sum{salary}}.sum()\"});\nbind(document, \"body.classList.has('dark')\", {\"<-\": \"darkMode\", source: viewModel});\n```\n\nFRB is built from a combination of powerful functional and generic\nbuilding blocks, making it reliable, easy to extend, and easy to\nmaintain.\n\n\n## Getting Started\n\n`frb` is a CommonJS package, with JavaScript modules suitable for use\nwith [Node.js][] on the server side or [Mr][] on the client side. \n\n```\n❯ npm install frb\n```\n\n[Node.js]: http://nodejs.org/\n[Mr]: https://github.com/kriskowal/mr\n\n\n\n## Tutorial\n\nIn this example, we bind `model.content` to `document.body.innerHTML`.\n\n```javascript\nvar bind = require(\"frb/bind\");\nvar model = {content: \"Hello, World!\"};\nvar cancelBinding = bind(document, \"body.innerHTML\", {\n    \"<-\": \"content\",\n    \"source\": model\n});\n```\n\nWhen a source property is bound to a target property, the target gets\nreassigned to the source any time the source changes.\n\n```javascript\nmodel.content = \"Farewell.\";\nexpect(document.body.innerHTML).toBe(\"Farewell.\");\n```\n\nBindings can be recursively detached from the objects they observe with\nthe returned cancel function.\n\n```javascript\ncancelBinding();\nmodel.content = \"Hello again!\"; // doesn't take\nexpect(document.body.innerHTML).toBe(\"Farewell.\");\n```\n\n### Two-way Bindings\n\nBindings can go one way or in both directions.  Declare one-way\nbindings with the ```<-``` property, and two-way bindings with the\n```<->``` property.\n\nIn this example, the \"foo\" and \"bar\" properties of an object will be\ninexorably intertwined.\n\n```javascript\nvar object = {};\nvar cancel = bind(object, \"foo\", {\"<->\": \"bar\"});\n\n// <-\nobject.bar = 10;\nexpect(object.foo).toBe(10);\n\n// ->\nobject.foo = 20;\nexpect(object.bar).toBe(20);\n```\n\n### Right-to-left\n\nNote that even with a two-way binding, the right-to-left binding\nprecedes the left-to-right.  In this example, \"foo\" and \"bar\" are bound\ntogether, but both have initial values.\n\n```javascript\nvar object = {foo: 10, bar: 20};\nvar cancel = bind(object, \"foo\", {\"<->\": \"bar\"});\nexpect(object.foo).toBe(20);\nexpect(object.bar).toBe(20);\n```\n\nThe right-to-left assignment of `bar` to `foo` happens first, so the\ninitial value of `foo` gets lost.\n\n### Property chains\n\nBindings can follow deeply nested chains, on both the left and the right\nside.\n\nIn this example, we have two object graphs, `foo`, and `bar`, with the\nsame structure and initial values.  This binds `bar.a.b` to `foo.a.b`\nand also the other way around.\n\n```javascript\nvar foo = {a: {b: 10}};\nvar bar = {a: {b: 10}};\nvar cancel = bind(foo, \"a.b\", {\n    \"<->\": \"a.b\",\n    source: bar\n});\n// <-\nbar.a.b = 20;\nexpect(foo.a.b).toBe(20);\n// ->\nfoo.a.b = 30;\nexpect(bar.a.b).toBe(30);\n```\n\nIn this case, the source of the binding is a different object than the\ntarget, so the binding descriptor specifies the alternate source.\n\n### Structure changes\n\nChanges to the structure of either side of the binding are no matter.\nAll of the orphaned event listeners will automatically be canceled, and\nthe binders and observers will reattach to the new object graph.\n\nContinuing from the previous example, we store and replace the `a`\nobject from one side of the binding.  The old `b` property is now\norphaned, and the old `b` property adopted in its place.\n\n```javascript\nvar a = foo.a;\nexpect(a.b).toBe(30); // from before\n\nfoo.a = {}; // orphan a and replace\nfoo.a.b = 40;\n// ->\nexpect(bar.a.b).toBe(40); // updated\n\nbar.a.b = 50;\n// <-\nexpect(foo.a.b).toBe(50); // new one updated\nexpect(a.b).toBe(30); // from before it was orphaned\n```\n\n### Sum\n\nSome advanced queries are possible with one-way bindings from\ncollections.\n\n```javascript\nvar object = {array: [1, 2, 3]};\nbind(object, \"sum\", {\"<-\": \"array.sum()\"});\nexpect(object.sum).toEqual(6);\n```\n\n### Average\n\n```javascript\nvar object = {array: [1, 2, 3]};\nbind(object, \"average\", {\"<-\": \"array.average()\"});\nexpect(object.average).toEqual(6);\n```\n\n### Map\n\nYou can also create mappings from one array to a new array and an\nexpression to evaluate on each item.  The mapped array is bound once,\nand all changes to the source array are incrementally updated in the\ntarget array.  Unaffected items in the array are not affected.\n\n```javascript\nvar object = {objects: [\n    {number: 10},\n    {number: 20},\n    {number: 30}\n]};\nbind(object, \"numbers\", {\"<-\": \"objects.map{number}\"});\nexpect(object.numbers).toEqual([10, 20, 30]);\nobject.objects.push({numbers: 40});\nexpect(object.numbers).toEqual([10, 20, 30]);\n```\n\nAny function, like `sum` or `average`, can be applied to the result of a\nmapping.  The straight-forward path would be\n`objects.map{number}.sum()`, but you can use a block with any function\nas a short hand, `objects.sum{number}`.\n\n### Flatten\n\nYou can flatten nested arrays.  In this example, we have an array of\narrays and bind it to a flat array.\n\n```javascript\nvar arrays = [[1, 2, 3], [4, 5, 6]];\nvar object = {};\nbind(object, \"flat\", {\n    \"<-\": \"flatten()\",\n    source: arrays\n});\nexpect(object.flat).toEqual([1, 2, 3, 4, 5, 6]);\n```\n\nNote that changes to the inner and outer arrays are both projected into\nthe flattened array.\n\n```javascript\narrays.push([7, 8, 9]);\narray[0].unshift(0);\nexpect(object.flat).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n```\n\nAlso, as with all other bindings that produce arrays, the flattened\narray is never replaced, just incrementally updated.\n\n```javascript\nvar flat = object.flat;\narrays.splice(0, arrays.length);\nexpect(object.flat).toBe(flat); // === same object\n```\n\n### Reversed\n\nYou can bind the reversal of an array.\n\n```javascript\nvar object = {forward: [1, 2, 3]};\nbind(object, \"backward\", {\n    \"<->\": \"reversed()\"\n});\nexpect(object.backward).toEqual([3, 2, 1]);\nobject.forward.push(4);\nexpect(object.forward).toEqual([1, 2, 3, 4]);\nexpect(object.backward).toEqual([4, 3, 2, 1]);\n```\n\nNote that you can do two-way bindings, ```<->``` with reversed arrays.\nChanges to either side are updated to the opposite side.\n\n```javascript\nobject.backward.pop();\nexpect(object.backward).toEqual([4, 3, 2]);\nexpect(object.forward).toEqual([2, 3, 4]);\n```\n\n### Has\n\nYou can bind a property to always reflect whether a collection contains\na particular value.\n\n```javascript\nvar object = {\n    haystack: [1, 2, 3],\n    needle: 3\n};\nbind(object, \"hasNeedle\", {\"<-\": \"haystack.has(needle)\"});\nexpect(object.hasNeedle).toBe(true);\nobject.haystack.pop(); // 3 comes off\nexpect(object.hasNeedle).toBe(false);\n```\n\nThe binding also reacts to changes to the value you seek.\n\n```javascript\n// continued from above\nobject.needle = 2;\nexpect(object.hasNeedle).toBe(true);\n```\n\n`has` bindings are not incremental, but with the right data-structure,\nupdates are cheap.  The [Collections][] package contains Lists, Sets,\nand OrderedSets that all can send content change notifications and thus\ncan be bound.\n\n[Collections]: https://github.com/kriskowal/collections\n\n```javascript\nvar Set = require(\"collections/set\");\nobject.haystack = new Set([1, 2, 3]);\nexpect(object.hasNeedle).toBe(true);\n```\n\n`has` bindings can also be left-to-right and bi-directional.\n\n```javascript\nbind(object, \"hasNeedle\", {\"<->\": \"haystack.has(needle)\"});\nobject.hasNeedle = false;\nexpect(object.haystack.has(2)).toBe(false);\n```\n\nThe collection on the left-hand-side must implement `has` or `contains`,\n`add`, and `delete` or `remove`.  FRB shims `Array` to have `has`,\n`add`, and `delete`, just like all the collections in [Collections][].\nIt happens that the `classList` properties of DOM elements, when they\nare supported, implement `add`, `remove`, and `contains`.\n\n```javascript\nvar model = {darkMode: false};\nbind(document.body, \"classList.has('dark')\", {\n    \"<-\": \"darkMode\",\n    source: model\n});\n```\n\nThe DOM `classList` does not however implement\n`addContentChangeListener` or `removeContentChangeListener`, so it\ncannot be used on the right-hand-side of a binding, and such bindings\ncannot be bidirectional.  With some DOM [Mutation Observers][], you\nmight be able to help FRB overcome this limitation in the future.\n\n[Mutation Observers]: https://developer.mozilla.org/en-US/docs/DOM/DOM_Mutation_Observers\n\n### Equals\n\nYou can bind to whether expressions are equal.\n\n```javascript\nvar fruit = {apples: 1, oranges: 2};\nbind(fruit, \"equal\", {\"<-\": \"apples == oranges\"});\nexpect(fruit.equal).toBe(false);\nfruit.orange = 1;\nexpect(fruit.equal).toBe(true);\n```\n\nEquality can be bound both directions.  In this example, we do a two-way\nbinding between whether a radio button is checked and a corresponding\nvalue in our model.\n\n```javascript\nbind(model, \"fruit = 'orange'\", {\n    \"<->\": \"checked\",\n    source: orangeElement\n});\nbind(model, \"fruit = 'apple'\", {\n    \"<->\": \"checked\",\n    source: appleElement\n});\n\norangeElement.checked = true;\nexpect(model.fruit).toEqual(\"orange\");\n\nappleElement.checked = true;\nexpect(model.fruit).toEqual(\"apple\");\n```\n\nBecause equality and assignment are interchanged in this language, you\ncan use either `=` or `==`.\n\n### Operators\n\nFRB can also recognize many operators.  These are in order of precedence\nunary `-` negation, `+` numeric coercion, and `!` logical negation and\nthen binary `**` power, `//` root, `%%` logarithm, `*`, `/`, `%` modulo,\n`%%` remainder, `+`, `-`, ```<```, ```>```, ```<=```, ```>=```, `=` or\n`==`, `!=`, `&&` and `||`.\n\n```javascript\nvar object = {height: 10};\nbind(object, \"heightPx\", {\"<-\": \"height + 'px'\"});\n```\n\n### Algebra\n\nFRB can automatically invert algebraic operators as long as they operate\nstrictly on numbers and the left-most expressions on both the source and\ntarget are bindable properties.\n\nIn this examlple, the primary binding is ```notToBe <- !toBe```, and the\ninverse binding is automatically computed ```toBe <- !notToBe```.\n\n```javascript\nvar caesar = {toBe: false};\nbind(caesar, \"notToBe\", {\"<->\": \"!toBe\"});\nexpect(caesar.toBe).toEqual(false);\nexpect(caesar.notToBe).toEqual(true);\n\ncaesar.notToBe = false;\nexpect(caesar.toBe).toEqual(true);\n```\n\nFRB does algebra by rotating the expressions on one side of a binding to\nthe other until only one independent property remains (the left most\nexpression) on the target side of the equation.\n\n```\nconvert: y <- !x\nrevert: x <- !y\n```\n\n```\nconvert: y <- x + a\nrevert: x <- y - a\n```\n\nThe left-most independent variable on the right hand side becomes the\ndependent variable on the inverted binding.  At present, this only works\nfor numbers and when the left-most expression is a bindable property\nbecause it cannot assign a new value to the literal 10.  For example,\nFRB cannot yet implicitly revert ```y <-> #10 + x```.\n\n### Literals\n\nYou may have noticed literals in the previous examples.  String literals\ntake the form of any characters between single quotes.  Any character\ncan be escaped with a back slash.\n\n```javascript\nvar object = {};\nbind(object, \"greeting\", {\"<-\": \"'Hello, World!'\"});\nexpect(object.greeting).toBe(\"Hello, World!\");\n```\n\nTo distingish array indicies from number literals, the number literal\nmust have a prefix `#`.\n\n```javascript\nvar array = [1, 2, 3];\nvar object = {};\nbind(object, 'zero', {\"<-\": \"#0\", source: array});\nbind(object, 'one', {\"<-\": \"0\", source: array});\n```\n\n### Tuples\n\nBindings can produce fixed-length arrays.  These are most useful in\nconjunction with mappings.  Tuples are comma-delimited and\nparantheses-enclosed.\n\n```javascript\nvar object = {array: [[1, 2, 3], [4, 5]]};\nbind(object, \"summary\", {\"<-\": \"array.map{(length, sum())}\"});\nexpect(object.summary).toEqual([\n    [3, 6],\n    [2, 9]\n]);\n```\n\n### Records\n\nBindings can also produce fixed-shape objects.  The notation is\ncomma-delimited, colon-separated items, enclosed by curly-braces.\n\n```javascript\nvar object = {array: [[1, 2, 3], [4, 5]]};\nbind(object, \"summary\", {\n    \"<-\": \"array.map{{length: length, sum: sum()}}\"\n});\nexpect(object.summary).toEqual([\n    {length: 3, sum: 6},\n    {length: 2, sum: 9}\n]);\n```\n\nThe left hand side of an item in a record is any combination of letters\nor numbers.  The right side is any expression.\n\n### Parameters\n\nBindings can also involve parameters.  The source of parameters is by\ndefault the same as the source.  The source, in turn, defaults to the\nsame as the target object.  It can be specified on the binding\ndescriptor.  Parameters are declared by any expression following a\ndollar sign.\n\n```javascript\nvar object = {a: 10, b: 20, c: 30};\nbind(object, \"foo\", {\n    \"<-\": \"($a, $b, $c)\"},\n    parameters: object\n});\n```\n\nBindings also react to changes to the parameters.\n\n```javascript\nobject.a = 0;\nobject.b = 1;\nobject.c = 2;\nexpect(object.foo).toEqual([0, 1, 2]);\n```\n\nThe degenerate case of the property language is an empty string.  This\nis a valid property path that observes the value itself.  So, as an\nemergent pattern, a `$` expression by itself corresponds to the whole\nparameters object.\n\n```javascript\nvar object = {};\nbind(object, \"ten\", {\"<-\": \"$\", parameters: 10});\nexpect(object.ten).toEqual(10);\n```\n\n### Observers\n\nFRB’s bindings use observers and binders internally.  You can create an\nobserver from a property path with the `observe` function exported by\nthe `frb/observe` module.\n\n```javascript\nvar object = {foo: {bar: 10}};\nvar cancel = observe(object, \"foo.bar\", function (value) {\n    // 10\n    // 20\n});\nobject.foo.bar = 10;\nobject.foo.bar = 20;\n```\n\nFor more complex cases, you can specify a descriptor instead of the\ncallback.  For example, to observe a property’s value *before it changes*, you can use the `beforeChange` flag.\n\n```javascript\nvar object = {foo: {bar: 10}};\nvar cancel = observe(object, \"foo.bar\", {\n    set: function (value) {\n        // 10\n        // 20\n    },\n    beforeChange: true\n});\nobject.foo.bar = 20;\nobject.foo.bar = 30;\n```\n\nIf the product of an observer is an array, that array is always updated\nincrementally.  It will only get emitted once.  If you want it to get\nemitted every time its content changes, you can use the `contentChange`\nflag.\n\n```javascript\nvar array = [[1, 2, 3], [4, 5, 6]];\nobserve(array, \"map{sum()}\", {\n    set: function (sums) {\n        // 1. [6, 15]\n        // 2. [6, 15, 0]\n        // 3. [10, 15, 0]\n    },\n    contentChange: true\n});\narray.push([0]);\narray[0].push(4);\n```\n\n### Nested Observers\n\nTo get the same effect as the previous example, you would have to nest\nyour own content change observer.\n\n```javascript\nvar array = [[1, 2, 3], [4, 5, 6]];\nvar cancel = observe(array, \"map{sum()}\", function (array) {\n    function contentChange() {\n        // 1. expect(array).toEqual([6, 15]);\n        // 2. expect(array).toEqual([6, 15, 0]);\n        // 3. expect(array).toEqual([10, 15, 0]);\n    }\n    array.addContentChangeListener(contentChange);\n    return function cancelContentChange() {\n        array.removeContentChangeListener(contentChange);\n    };\n});\narray.push([0]);\narray[0].push(4);\ncancel();\n```\n\nThis illustrates one crucial aspect of the architecture.  Observers\nreturn cancelation functions.  You can also return a cancelation\nfunction inside a callback observer.  That canceler will get called each\ntime a new value is observed, or when the parent observer is canceled.\nThis makes it possible to nest observers.\n\n```javascript\nvar object = {foo: {bar: 10}};\nvar cancel = observe(object, \"foo\", function (foo) {\n    return observe(foo, \"bar\", function (bar) {\n        expect(bar).toBe(10);\n    });\n});\n```\n\n### Bindings\n\nFRB provides utilities for declaraing and managing multiple bindings on\nobjects.  The `frb` (`frb/bindings`) module exports this interface.\n\n```javascript\nvar Bindings = require(\"frb\");\n```\n\nThe `Bindings.create` and `Bindings.define` methods have a similar\ninterface.  The `create` function creates a new object with properties\nand bindings.  The `define` function augments an existing object.  The\nproperties object is just key value pairs to copy to the object, for\nconvenience.\n\n```javascript\nvar object = Bindings.create(Object.prototype, {\n    a: 10,\n    b: 20\n});\nexpect(object.a).toEqual(10);\nexpect(object.b).toEqual(20);\n\nBindings.define(object, {\n    b: 30,\n    c: 50\n});\nexpect(object.b).toEqual(30);\nexpect(object.c).toEqual(50);\n```\n\n### Binding Descriptors\n\nThe third argument of both `create` and `define` is an object containing\nproperty descriptors.  These are the same property descriptors you see\nwith EcmaScript 5’s `Object.defineProperty`.  They additionally can\ncontain bindings or dependent paths.\n\nIf a descriptor has a ```<-``` or ```<->```, it is a binding descriptor.\nFRB creates a binding, adds the canceler to the descriptor, and adds the\ndescriptor to an internal table that tracks all of the bindings defined\non that object.\n\n```javascript\nvar object = Bindings.create(null, {\n    darkMode: false,\n    document: document\n}, {\n    \"document.body.classList.has('dark')\": {\n        \"<-\": \"darkMode\"\n    }\n});\n```\n\nYou can get all the binding descriptors with `Bindings.getBindings`, or a\nsingle binding descriptor with `Bindings.getBinding`.  `Bindings.cancel` cancels\nall the bindings to an object and `Bindings.cancelBinding` will cancel just\none.\n\n```javascript\nvar bindings = Bindings.getBindings(object);\nvar descriptor = Bindings.getBinding(object, \"document.body.classList.has('dark')\");\nBindings.cancelBinding(object, \"document.body.classList.has('dark')\");\nBindings.cancel(object);\n```\n\n### Converters\n\nA binding descriptor can have a `convert` function, a `revert` function,\nor alternately a `converter` object.  Converters are useful for\ntransformations that cannot be expressed in the property language, or\nare not reversible in the property language.\n\nIn this example, `a` and `b` are synchronized such that `a` is always\nhalf of `b`, regardless of which property gets updated.\n\n```javascript\nBindings.create(null, {\n    a: 10\n}, {\n    b: {\n        \"<-\": a\n        convert: function (a) {\n            return a * 2;\n        },\n        revert: function (b) {\n            return a / 2;\n        }\n    }\n});\n```\n\nConverter objects are useful for reusable or modular converter types and\nconverters that track additional state.\n\n```javascript\nBindings.create(null, {\n    a: 10\n}, {\n    b: {\n        \"<-\": a\n        converter: {\n            factor: 2,\n            convert: function (a) {\n                return a * this.factor;\n            },\n            revert: function (b) {\n                return a / this.factor;\n            }\n        }\n    }\n});\n```\n\n### Computed Properties\n\nA computed property is one that gets updated with a function call when\none of its arguments changes.  Like a converter, it is useful in cases\nwhere a transformation or computation cannot be expressed in the\nproperty language, but can additionally accept multiple arguments as\ninput.  A computed property can be used as the source for another\nbinding.\n\nIn this example, we create an object as the root of multiple bindings.\nThe object synchronizes the properties of a \"form\" object with the\nwindow’s search string, effectively navigating to a new page whenever\nthe \"q\" or \"charset\" entries of the form change.\n\n```javascript\nBindings.create(null, {\n    window: window,\n    form: {\n        q: \"\",\n        charset: \"utf-8\"\n    }\n}, {\n    queryString: {\n        args: [\"form.q\", \"form.charset\"],\n        compute: function (q, charset) {\n            return \"?\" + QS.stringify({\n                q: q,\n                charset: charset\n            });\n        }\n    },\n    \"window.location.search\": {\n        \"<-\": \"queryString\"\n    }\n});\n```\n\n### Debugging with Traces\n\nA binding can be configured to log when it changes and why.  The `trace`\nproperty on a descriptor instructs the binder to log changes to the\nconsole.\n\n```javascript\nBindings.create(null, {\n    a: 10\n}, {\n    b: {\n        \"<-\": \"a + #1\",\n    }\n});\n```\n\n## Reference\n\nFunctional Reactive Bindings is an implementation of synchronous,\nincremental object-property and collection-content bindings for\nJavaScript.  It was ripped from the heart of the [Montage][] web\napplication framework and beaten into this new, slightly magical form.\nIt must prove itself worthy before it can return.\n\n[Montage]: https://github.com/montagejs/montage\n\n-   **functional**: The implementation uses functional building blocks\n    to compose observers and binders.\n-   **generic**: The implementation uses generic methods on collections,\n    like `addContentChangeListener`, so any object can implement the\n    same interface and be used in a binding.\n-   **reactive**: The values of properties and contents of collections\n    react to changes in the objects and collections on which they\n    depend.\n-   **synchronous**: All bindings are made consistent in the statement\n    that causes the change.  The alternative is asynchronous, where\n    changes are queued up and consistency is restored in a later event.\n-   **incremental**: If you update an array, it produces a content\n    change which contains the values you added, removed, and the\n    location of the change.  Most bindings can be updated using only\n    these values.  For example, a sum is updated by decreasing by the\n    sum of the values removed, and increasing by the sum of the values\n    added.  FRB can incrementally update `map`, `reversed`, `flatten`,\n    `sum`, and `average` observers.  It can also incrementally update\n    `has` bindings.\n-   **unwrapped**: Rather than wrap objects and arrays with observable\n    containers, FRB modifies existing arrays and objects to make them\n    dispatch property and content changes.  For objects, this involves\n    installing getters and setters using the ES5 `Object.defineProperty`\n    method.  For arrays, this involves replacing all of the mutation\n    methods, like `push` and `pop`, with variants that dispatch change\n    notifications.  The methods are either replaced by swapping the\n    `__proto__` or adding the methods to the instance with\n    `Object.defineProperties`.  These techniques should [work][]\n    starting in Internet Explorer 9, Firefox 4, Safari 5, Chrome 7, and\n    Opera 12.\n\n[work]: http://kangax.github.com/es5-compat-table/#define-property-webkit-note\n\n\n### Architecture\n\n-   **property and content change events** for objects and arrays using\n    getters and setters for observable objects and either prototype\n    swapping or method override for observable arrays.  Other collection\n    types can implement the same interface to be compatible with all\n    subsequent layers.  Caveats: you have to use a `set` method on\n    Arrays to dispatch property and content change events.  Does not\n    work in older Internet Explorers since they support neither\n    prototype assignment or ES5 property setters.\n-   **observer** functions for watching an entire object graph for\n    incremental changes, and gracefully rearranging and canceling those\n    observers as the graph changes.  Observers can be constructed\n    directly or with a very small query language that compiles to a tree\n    of functions so no parsing occurs while the graph is being watched.\n-   one- and two-way **bindings** for incrementally updating properties\n    with the results of observed queries.\n-   **declarative** interface for creating an object graph with\n    bindings, properties, and computed properties with dependencies.\n\n\n### Bindings\n\nThe highest level interface for FRB resembles the ES5 Object constructor\nand can be used to declare objects and define and cancel bindings on\nthem with extended property descriptors.\n\n```javascript\nvar Bindings = require(\"frb\");\n\n// create an object\nvar object = Bindings.create(null, { // prototype\n    // simple properties\n    foo: 0,\n    graph: [\n        {numbers: [1,2,3]},\n        {numbers: [4,5,6]}\n    ]\n}, {\n    // extended property descriptors\n    bar: {\"<->\": \"foo\", enumerable: false},\n    numbers: {\"<-\": \"graph.map{numbers}.flatten()\"},\n    sum: {\"<-\": \"numbers.sum()\"},\n    reversed: {\"<-\": \"numbers.reversed()\"}\n});\n\nexpect(object.bar).toEqual(object.foo);\nobject.bar = 10;\nexpect(object.bar).toEqual(object.foo);\nexpect.foo = 20;\nexpect(object.bar).toEqual(object.foo);\n\n// note that the identity of the bound numbers array never\n// changes, because all of the changes to that array are\n// incrementally updated\nvar numbers = object.numbers;\n\n// first computation\nexpect(object.sum).toEqual(21);\n\n// adds an element to graph,\n// which pushes [7, 8, 9] to \"graph.map{numbers}\",\n// which splices [7, 8, 9] to the end of\n//  \"graph.map{numbers}.flatten()\",\n// which increments \"sum()\" by [7, 8, 9].sum()\nobject.graph.push({numbers: [7, 8, 9]});\nexpect(object.sum).toEqual(45);\n\n// splices [1] to the beginning of [1, 2, 3],\n// which splices [1] to the beginning of \"...flatten()\"\n// which increments \"sum()\" by [1].sum()\nobject.graph[0].numbers.unshift(1);\nexpect(object.sum).toEqual(46);\n\n// cancels the entire observer hierarchy, then attaches\n//  listeners to the new one.  updates the sum.\nobject.graph = [{numbers: [1,2,3]}];\nexpect(object.sum).toEqual(6);\n\nexpect(object.reversed).toEqual([3, 2, 1]);\n\nexpect(object.numbers).toBe(numbers) // still the same object\n\nBindings.cancelBindings(object); // cancels all bindings on this object and\n// their transitive observers and event listeners as deep as\n// they go\n```\n\n-   `Bindings.create(prototype, properties, descriptors)`\n-   `Bindings.define(object, properties, descriptors)`\n-   `Bindings.defineBinding(object, name, descriptor)`\n-   `Bindings.getBindings(object)`\n-   `Bindings.getBinding(object, name)`\n-   `Bindings.cancelBindings(object)`\n-   `Bindings.cancelBinding(object, name)`\n\nA binding descriptor contains:\n\n-   `target`: the\n-   `targetPath`: the target\n-   `targetSyntax`: the syntax tree for the target path\n-   `source`: the source object, which defaults to `target`\n-   `sourcePath`: the source path, from either ```<-``` or ```<->```\n-   `sourceSyntax`: the syntax tree for the source path\n-   `twoWay`: whether the binding goes in both directions, if ```<->```\n    was the source path.\n-   `parameters`: the parameters, which default to `source`.\n-   `cancel`: a function to cancel the binding\n\n### Bind\n\nThe `bind` module provides direct access to the `bind` function.\n\n```javascript\nvar bind = require(\"frb/bind\");\n\nvar source = [{numbers: [1,2,3]}, {numbers: [4,5,6]}];\nvar target = {};\nvar cancel = bind(target, \"summary\", {\n    \"<-\": \"map{(numbers.sum(), numbers.average())}\",\n    source: source\n});\n\nexpect(target.summary).toEqual([\n    [6, 2],\n    [15, 5]\n]);\n\ncancel();\n```\n\n`bind` is built on top of `parse`, `compileBinder`, and\n`compileObserver`.\n\n### Compute\n\nThe `compute` module provides direct access to the `compute` function,\nused by `Bindings` to make computed properties.\n\n```javascript\nvar compute = require(\"frb/compute\");\n\nvar source = {operands: [10, 20]};\nvar target = {};\nvar cancel = compute(target, \"sum\", {\n    source: source,\n    args: [\"operands.0\", \"operands.1\"],\n    compute: function (a, b) {\n        return a + b;\n    }\n});\n\nexpect(target.sum).toEqual(30);\n\n// change one operand\nsource.operands.set(1, 30); // needed to dispatch change notification\nexpect(target.sum).toEqual(40);\n```\n\n### Observers\n\nThe `observe` modules provides direct access to the `observe` function.\n`observe` is built on top of `parse` and `compileObserver`.\n`compileObserver` creates a tree of observers using the methods in the\n`observers` module.\n\n```javascript\nvar observe = require(\"frb/observe\");\n\nvar source = [1, 2, 3];\nvar sum;\nvar cancel = observe(source, \"sum()\", function (newSum) {\n    sum = newSum;\n});\n\nexpect(sum).toBe(6);\n\nsource.push(4);\nexpect(sum).toBe(10);\n\nsource.unshift(0); // no change\nexpect(sum).toBe(10);\n\ncancel();\nsource.splice(0, source.length); // would change\nexpect(sum).toBe(10);\n```\n\n`observe` produces a cancelation hierarchy.  Each time a value is\nremoved from an array, the underlying observers are canceled.  Each time\na property is replaced, the underlying observer is canceled.  When new\nvalues are added or replaced, the observer produces a new canceler.  The\ncancel function returned by `observe` commands the entire underlying\ntree.\n\nObservers also optional accept a descriptor argument in place of a\ncallback.\n\n-   `set`: the change handler, receives `value` for most observers, but\n    also `key` and `object` for property changes.\n-   `parameters`: the value for `$` expressions.\n-   `beforeChange`: instructs an observer to emit the previous value\n    before a change occurs.\n-   `contentChange`: instructs an observer to emit an array every time\n    its content changes.  By default, arrays are only emitted once.\n\n```javascript\nvar object = {};\nvar cancel = observe(object, \"array\", {\n    set: function (value) {\n        // may return a cancel function for a nested observer\n    },\n    parameters: {},\n    beforeChange: false,\n    contentChange: true\n});\n\nobject.array = []; // emits []\nobject.array.push(10); // emits [10]\n```\n\n\n### The Language\n\nBindings and observers used a small query language intended to resemble\nthe same code that you would write in JavaScript to update a binding by\nbrute force.\n\n#### Grammar\n\n-   **expression** = **logical or expression**\n-   **logical or expression** = **logical and expression** ( `||`\n    **relation expression** )?\n-   **logical and expression** = **relation expression** ( `&&`\n    **relation expression** )?\n-   **relation expression** = **arithmetic expression** ( **relation\n    operator** **arithmetic expression** )?\n-   **relation operator** = `=` | `==` | `<` | `<=` | `>` | `>=`\n-   **arithmetic expression** = **multiplicative expresion** *delimited\n    by* **arithmetic operator**\n-   **arithmetic operator** = `+` | `-`\n-   **multiplicative expression** = **exponential expression**\n    *delimited by* **multiplicative operator**\n-   **multiplicative operator** = `*` | `/` | `%` | `rem`\n-   **exponential expression** = **unary expression** *delimited by*\n    **exponential operator**\n-   **exponential operator** = `**` | `//` | `%%`\n-   **unary expression** = **unary operator** ? **chain expression**\n-   **unary operator** = `+` | `-` | `!`\n-   **chain expression** = **primary expression** *delimited by* `.`\n    ( `.*` )?\n-   **primary expression** = **literal** *or* `(` **expression** `)`\n    *or* **property name** *or* **function call** *or* **block call**\n-   **property name** = ( **non space character** )+\n-   **block name** = **function name** *or* `map`\n-   **function name** = `flatten` *or* `reversed` *or* `sum` *or*\n    `average` *or* `has`\n-   **function call** = **function name** `(` **tuple** `)`\n-   **block call** = **function name** `{` **expression** `}`\n-   **tuple** = **expression** *delimited by* `,`\n-   **literal** = **string literal** *or* **number literal**\n-   **number literal** = `#` ( **non space character** )+\n-   **string literal** = `'` ( **non quote character** *or* `\\`\n    **character** )* `'`\n\n#### Semantics\n\nAn expression is observed with a source value and emits a target\none or more times.  All expressions emit an initial value.  Array\ntargets are always updated incrementally.  Numbers and boolean are\nemited anew each time their value changes.\n\nIf any operand is `null` or `undefine`, a binding will not emit an\nupdate.  Thus, if a binding’s source becomes invalid, it does not\ncorrupt its target but waits until a valid replacement becomes\navailable.\n\n-   In a chained expression, the first term is evaluated with the source\n    value.\n-   Each subsequent term uses the target of the previous as its source.\n-   Literals are interpreted as their corresponding value.\n-   A property expression observes the named key of the source object.\n-   A \"map\" block observes the source array and emits a target array.\n    The target array is emitted once and all subsequent updates are\n    reflected as content changes that can be independently observed with\n    `addContentChangeListener`.  Each element of the target array\n    corresponds to the observed value of the block expression using the\n    respective element in the source array as the source value.\n-   Any function call with a \"block\" implies calling the function on the\n    result of a \"map\" block.\n-   A \"flatten\" function call observes a source array and produces a\n    target array.  The source array must only contain inner arrays.  The\n    target array is emitted once and all subsequent updates can be\n    independently observed with `addContentChangeListener`.  The target\n    array will always contain the concatenation of all of the source\n    arrays.  Changes to the inner and outer source arrays are reflected\n    with incremental splices to the target array in their corresponding\n    positions.\n-   A \"reversed\" function call observes the source array and produces a\n    target array that contains the elements of the source array in\n    reverse order.  The target is incrementally updated.\n-   A \"sum\" function call observes the numeric sum of the source array.\n    Each alteration to the source array causes a new sum to be emitted,\n    but the sum is computed incrementally by observing the smaller sums\n    of the spliced values, added and removed.\n-   An \"average\" function call observes the average of the input values,\n    much like \"sum\".\n-   A \"has\" function call observes the source collection for whether it\n    contains an observed value.\n-   A \"tuple\" expression observes a source value and emits a single\n    target array with elements corresponding to the respective\n    expression in the tuple.  Each inner expression is evaluated with\n    the same source value as the outer expression.\n-   `.*` at the end of a chain has no effect on an observed value.\n\nOn the left hand side of a binding, the last term has alternate\nsemantics.  Binders receive a target as well as a source.\n\n-   A \"property\" observes an object and a property name from the target,\n    and a value from the source.  When any of these change, the binder\n    upates the value for the property name of the object.\n-   A \"equals\" expression observes a boolean value from the source.  If\n    that boolean becomes true, the equality expression is made true by\n    assigning the right expression to the left property of the equality,\n    turning the \"equals\" into an \"assign\" conceptually.  No action is\n    taken if the boolean becomes false.\n-   A \"reversed\" expression observes an indexed collection and maintains\n    a mirror array of that collection.\n-   A \"has\" function call observes a boolean value from the source, and\n    an collection and a sought value from the target.  When the value is\n    true and the value is absent in the collection, the binder uses the\n    `add` method of the collection (provided by a shim for arrays) to\n    make it true that the collection contains the sought value.  When\n    the value is false and the value does appear in the collection one\n    or more times, the binder uses the `delete` or `remove` method of\n    the collection to remove all occurrences of the sought value.\n\nIf the target expression ends with `.*`, the content of the target is\nbound instead of the property.  This is useful for binding the content\nof a non-array collection to the content of another indexed collection.\nThe collection can be any collection that implements the \"observable\ncontent\" interface including `dispatchContentChange(plus, minus,\nindex)`, `addContentChangeListener`, and `removeContentChangeListener`.\n\n#### Interface\n\n```javascript\nvar parse = require(\"frb/parse\");\nvar compileObserver = require(\"frb/compile-observer\");\nvar compileBinder = require(\"frb/compile-binder\");\n```\n\n-   `parse(text)` returns a syntax tree.\n-   `compileObserver(syntax)` returns an observer function of the form\n    `observe(callback, source, parameters)` which in turn returns a\n    `cancel()` function.  `compileObserver` visits the syntax tree and\n    creates functions for each node, using the `observers` module.\n-   `compileBinder(syntax)` returns a binder function of the form\n    `bind(observeValue, source, target, parameters)` which in turn\n    returns a `cancel()` function.  `compileBinder` visits the root node\n    of the syntax tree and delegates to `compileObserver` for its terms.\n    The root node must be a `property` at this time, but could\n    conceivably be any function with a clear inverse operation like\n    `map` and `reversed`.\n\n#### Syntax Tree\n\nThe syntax tree is JSON serializable and has a \"type\" property.  Nodes\nhave the following types:\n\n-   `value` corresponds to observing the source value\n-   `parameters` corresponds to observing the parameters object\n-   `literal` has a `value` property and observes that value\n\nAll other node types have an \"args\" property that is an array of syntax\nnodes.\n\n-   `property`: corresponds to observing a property named by the right\n    argument of the left argument.\n-   `map`: the left is the input, the right is an expression to observe\n    on each element of the input.\n-   `tuple`: has any number of arguments, each an expression to observe\n    in terms of the source value.\n\nFor all operators, the \"args\" property are operands.  The node types for\nunary operators are:\n\n-   ```+```: `number`, arithmetic coercion\n-   ```-```: `neg`, arithmetic negation\n-   ```!```: `not`, logical negation\n\nFor all binary operators, the node types are:\n\n-   ```**```: `pow`, exponential power\n-   ```//```: `root`, binary\n-   ```%%```: `log`, logarithm with base\n-   ```*```: `mul`, multiplication\n-   ```/```: `div`, division\n-   ```%```: `mod`, modulo (toward negative infinity, always positive)\n-   ```rem```: `rem`, remainder (toward zero, negative if negative)\n-   ```+```: `add`, addition\n-   ```-```: `sub`, subtraction\n-   ```<```: `lt`, less than\n-   ```<=````: `le`, less than or equal\n-   ```>```: `gt`, greater than\n-   ```>=```: `ge`, greater than or equal\n-   ```=``` and ```==```: ``equals``, equality comparison and assignment\n-   ```!=``` produces unary negation and equality comparison or\n    assignment so does not have a corresponding node type.  The\n    simplification makes it easier to rotate the syntax tree\n    algebraically.\n-   ```&&```, `and`, logical and\n-   ```||```, `or`, logical or\n\nFor all function calls, the right hand side is a tuple of arguments,\npresently ignored.\n\n-   `reversed`\n-   `flatten`\n-   `sum`\n-   `average`\n\n\n### Observers and Binders\n\nThe `observers` module contains functions for making all of the\ndifferent types of observers, and utilities for creating new ones.\nAll of these functions are or return an observer function of the form\n`observe(emit, value, parameters)` which in turn returns `cancel()`.\n\n-   `observeValue`\n-   `observeParameters`\n-   `makeLiteralObserver(value)`\n-   `makeRelationObserver(callback, thisp)` is unavailable through the\n    property binding language, translates a value through a JavaScript\n    function.\n-   `makeComputerObserver(observeArgs, compute, thisp)` applies\n    arguments to the computation function to get a new value.\n-   `makeConverterObserver(observeValue, convert, thisp)` calls the\n    converter function to transform a value to a converted value.\n-   `makePropertyObserver(observeObject, observeKey)`\n-   `makeMapObserver(observeArray, observeRelation)`\n-   `makeTupleObserver(...observers)`\n-   `makeObserversObserver(observers)`\n-   `makeReversedObserver(observeArrayh)`\n-   `makeWindowObserver` is not presently available through the language\n    and is subject to change.  It is for watching a length from an array\n    starting at an observable index.\n-   `makeFlattenObserver(observeArray)`\n-   `makeSumObserver(observeArray)`\n-   `makeAverageObserver(observeArray)`\n\nThese are utilities for making observer functions.\n\n-   `makeNonReplacing(observe)` accepts an array observer (the emitted\n    values must be arrays) and returns an array observer that will only\n    emit the target once and then incrementally update that target.  All\n    array observers use this decorator to handle the case where the\n    source value gets replaced.\n-   `makeArrayObserverMaker(setup)` generates an observer that uses an\n    array as its source and then incrementally updates a target value,\n    like `sum` and `average`.  The `setup(source, emit)` function must\n    return an object of the form `{contentChange, cancel}` and arrange\n    for `emit` to be called with new values when `contentChange(plus,\n    minus, index)` receives incremental updates.\n-   `makeUniq(callback)` wraps an emitter callback such that it only\n    forwards new values.  So, if a value is repeated, subsequent calls\n    are ignored.\n-   `autoCancelPrevious(callback)` accepts an observer callback and\n    returns an observer callback.  Observer callbacks may return\n    cancelation functions, so this decorator arranges for the previous\n    canceler to be called before producing a new one, and arranges for\n    the last canceler to be called when the whole tree is done.\n-   `once(callback)` accepts a canceler function and ensures that the\n    cancelation routine is only called once.\n\nThe `binders` module contains similar functions for binding an observed\nvalue to a bound value.  All binders are of the form `bind(observeValue,\nsource, target, parameters)` and return a `cancel()` function.\n\n-   `makePropertyBinder(observeObject, observeKey)`\n-   `makeHasBinder(observeCollection, observeValue)`\n\n\n### Change Events\n\n#### Object Property Changes\n\nTo use object observers, `require(\"frb/properties\")`.  Observers depend\non EcmaScript 5's `Object.defineProperty` and `Object.defineProperties`\nor a suitable shim.  Observable collections benefit from the ability to\nswap `__proto__` in all engines except Internet Explorer, in which case\nthey fall back to using `Object.defineProperties` to trap change\nfunctions.\n\nListen for individual property changes on an object.  The listener may\nbe a function or a delegate.\n\n-   `addOwnPropertyChangeListener(object, key, listener, beforeChange)`\n-   `removeOwnPropertyChangeListener(object, key, listener, beforeChange)`\n-   `addBeforeOwnPropertyChangeListener(object, key, listener)`\n-   `removeBeforeOwnPropertyChangeListener(object, key, listener)`\n\nThe arguments to the listener are `(value, key, object)`, much like a\n`forEach` callback.  The `this` within the listener is the listener\nobject itself.  The dispatch method must be one of these names, favoring\nthe most specific provided.\n\n-   `handle` + key (TwoHump) + (`Change` or `WillChange` before change),\n    for example, `handleFooWillChange` for `foo`.\n-   `handleOwnPropertyChange` or `handleOwnPropertyWillChange` before\n    change\n-   `handleEvent`\n-   function\n\n#### Custom Property Change Observers\n\nThe property change listener functions delegate to a\n`makePropertyObservable(key)` and `makePropertyUnobservable(key)` if\nthey exist.  So, these can be used to augment host objects, like parts\nof the DOM, to accommodate property change listeners.  The `dom` module\nmonkey-patches HTML element prototoypes to make some properties\nobservable, like the \"checked\" property of radio and checkbox input\nelements using the `addEventListener(\"change\")` interface.\n\n#### Array Content Changes\n\nTo use array content observers,\n`require(\"frb/array\")`.  This will install the\nnecessary methods on the `Array` prototype.  The performance of arrays\nin general will not be affected&mdash;only observed arrays will require\nmore time to execute changes.\n\nListen for ranged content changes on arrays.  The location of the change\nis where the given arrays of content are removed and added.  For\nunordered collections like sets, the location would not be defined.\nContent changes are not yet implemented for other collections.\n\n-   `array.addContentChangeListener(listener, beforeChange)`\n-   `array.removeContentChangeListener(listener, beforeChange)`\n-   `array.addBeforeContentChangeListener(listener)`\n-   `array.removeBeforeContentChangeListener(listener)`\n\nThe arguments to the listener are `(plus, minus, at)`, which are arrays\nof the added and removed values, and optionally the location of the\nchange for ordered collections (lists, arrays).  For a list, the\nposition is denoted by a node.  The dispatch method must be one of these\nnames, favoring the most specific provided.\n\n-   `handleContentChange` or `handleContentWillChange` if before change\n-   `handleEvent`\n-   function\n\nListen for content changes from each position within an array, including\nchanges to and from undefined.  Content changes must be emitted by\nmethod calls on an array, so use `array.set(index, value)` instead of\n`array[index] = value`.\n\n-   `array.addEachContentChangeListener(listener, beforeChange)`\n-   `array.removeEachContentChangeListener(listener, beforeChange)`\n-   `array.addBeforeEachContentChangeListener(listener)`\n-   `array.removeBeforeEachContentChangeListener(listener)`\n\nThe listener is a listener as for property changes.\n\n",
  "_id": "frb@0.0.7",
  "dist": {
    "shasum": "381ae1625d947b77c222fa1fbc987d57fe651962"
  },
  "_from": "frb@0.0.7"
}
