{
  "name": "collections",
  "version": "0.0.7",
  "description": "data structures with idiomatic JavaScript collection interfaces",
  "homepage": "http://github.com/kriskowal/collections",
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com",
    "url": "http://github.com/kriskowal/collections"
  },
  "keywords": [
    "collections",
    "data structures",
    "observable",
    "list",
    "set",
    "map",
    "splay"
  ],
  "bugs": {
    "mail": "kris@cixar.com",
    "url": "http://github.com/kriskowal/collections/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/kriskowal/collections/raw/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/kriskowal/collections.git"
  },
  "dependencies": {},
  "devDependencies": {
    "jasmine-node": "*"
  },
  "readme": "\n# Collections\n\nThis package contains JavaScript implementations of common data\nstructures with idiomatic iterfaces, including extensions for Array and\nObject.\n\n-   `List(values, equals)`: an ordered collection of values with fast\n    insertion and deletion and forward and backward traversal, backed by\n    a cyclic doubly linked list with a head node.  Lists support most of\n    the Array interface, except that they use and return nodes instead\n    of integer indicies in analogous functions.\n-   `Set(values, equals, hash)`: a collection of unique values stored like\n    a hash table.  The underlying storage is a plain JavaScript object\n    that maps hashes to lists of values that share the same hash.\n    Values may be objects.  The `equals` and `hash` functions can be\n    overridden to provide alternate definitions of \"unique\".  This\n    collection is intended to be replaced by a native implementation\n    that does not rely on `hash`.\n-   `Map(map, equals, hash)`: a collection of key and value items with\n    unique keys, backed by a set.  Keys may be objects.  This collection\n    is intended to be replaced by a native implementation that does not\n    rely on `hash`.\n-   `SortedSet(values, equals, compare)`: a collection of unique values\n    stored in stored order, backed by a splay tree.  The `equals` and\n    `compare` functions can be overridden to provide alternate\n    definitions of \"unique\".\n-   `SortedMap(map, equals, compare)`: a collection of key value pairs\n    stored in sorted order, backed by a sorted set.\n-   `WeakMap()`: a non-iterable collection of key value pairs.  Keys\n    must objects and do not benefit from `hash` functions.  Some engines\n    already implement `WeakMap`.  The non-iterable requirement makes it\n    possible for weak maps to collect garbage when the key is no longer\n    available, without betraying when the key is collected.  The shimmed\n    implementation undetectably annotates the given key and thus does\n    not necessarily leak memory, but cannot collect certain reference\n    graphs.  This WeakMap shim was implemented by Mark Miller of Google.\n-   `Iterator(iterable)`: a wrapper for any iterable that implements\n    `iterate` or iterator the implements `next`, providing a rich lazy\n    traversal interface.\n-   `Array()`: an ordered collection of values with fast random access,\n    push, and pop, but slow splice. The `array` module provides\n    extensions so it hosts all the expressiveness of other collections.\n    The `array-shim` module shims EcmaScript 5 methods onto the array\n    prototype if they are not natively implemented.\n-   `Object()`: can be used as a mapping of owned string keys to\n    arbitrary values.  The `object` module provides extensions for the\n    `Object` constructor that support the map collection interface and\n    can delegate to methods of collections, allowing them to gracefully\n    handle both object literals and collections.\n\nFor all of these constructors, the argument `values` is an optional\ncollection of initial values, and may be an array.  If the `values` are\nin a map collection, the the values are taken, but the keys are ignored.\n\nThe `map` argument is an optional collection to copy shallowly into the\nnew mapping.  The `map` may be an object literal.  If `map` implements\n`forEach`, the values for each key are copied.  So, `map` may be an\narray, where each index is accepted as the key.\n\n`equals(x, y)`, `compare(x, y)`, and `hash(value)` are all optional\narguments overriding the meaning of equality, comparability, and\nconsistent hashing for the purposes of the collection.  `equals` must\nreturn a boolean.  `compare` must return an integer with the same\nrelationship to zero as x to y.  `hash` should consistently return the same\nstring for any given object.\n\nThe default `equals` operator is implemented in terms of `===`, but\ntreats `NaN` as equal to itself and `-0` as distinct from `+0`.  It also\ndelegates to an `equals` method of either the left or right argument if\none exists.  The default can be overridden by shimming `Object.equals`.\n\nThe default `compare` operator is implemented in terms of `<` and `>`.\nIt delegates to the `compare` method of either the left or right\nargument if one exists.  It inverts the result if it uses the falls to\nthe right argument.  The default can be overridden by shimming\n`Object.compare`.\n\nThe default `hash` operator is implemented in terms of `toString`, but\ndefers to the value's own `hash` member function if it provides one.  If\nthe hash changes, corresponding values will not be retrievable within\nsets or maps that use it.  The default `hash` operator can be overridden\nby shimming `Object.hash`.\n\nConsistent hashing is tricky in JavaScript since the language\ndeliberately avoids providing unique values for each object.  However,\nin conjunction with `WeakMap`, it is relatively easy to add a [Unique\nLabel][] to objects.\n\n[Unique Label]: (http://wiki.ecmascript.org/doku.php?id=harmony:weak_maps#unique_labeler)\n\nThe `hash` module provides such an implementation.  Since it entrains\nall the weight of the the `weap-map` module, you must opt in by\nrequiring the module.  If loaded, all new `Map` instances benefit from\nfewer hash collisions without the need for per-key-type implementations\nof `hash`.\n\n\n## Collection Methods\n\nWhere these methods coincide with the specification of an existing\nmethod of Array, Array is noted as an implementation.  `Array+` refers\nto shimmed arrays, as installed with the `array` module.  `Object`\nrefers to methods implemented on the `Object` constructor function, as\nopposed to the `Object.prototype`.  `Object+` in turn refers to methods\nshimmed on the object constructor by the `object` module.  These\nfunctions accept the object as the first argument instead of the `this`\nimplied argument.\n\n-   `has(key)`: (Map, SortedMap, WeakMap) whether a value for the given\n    key exists.\n-   `has(value, opt_equals)`: (List, Set, SortedSet, Array+, Object+)\n    whether a value exists.  collection.  This is slow for list\n    (linear), but fast (logarithmic) for Set and SortedSet.\n-   `get(key)`: (Map, SortedMap, WeakMap, Array+, Object+) the value for\n    a key.  If a Map or SortedMap lacks a key, returns\n    `getDefault(key)`.\n-   `getDefault(value)`: (Map, SortedMap) returns undefined.\n-   `get(value)`: (List, Set, SortedSet) gets the equivalent value, or\n    falls back to `getDefault(value)`.\n-   `getDefault(key)`: (List, Set, SortedSet) returns undefined.\n-   `set(key, value)`: (Map, SortedMap, WeakMap, Array+, Object+) sets\n    the value for a key.\n-   `add(value)`: (List, Set, SortedSet) adds a value.  Sets silently\n    drop the value if an equivalent value already exists.\n-   `add(value, key)`: (Map, SortedMap, Array+) sets the value for a\n    key, convenient in conjunction with `forEach` due to the callback\n    argument order.\n-   `addEach(values)`: (List, Set, Map, SortedSet, SortedMap, Array+)\n    adds all values or key value pairs to this collection.  Works for\n    arrays and objects as well as any other collection.\n-   `delete(key)`: (Map, SortedMap, WeakMap, Array+) deletes the value\n    for a given key.  Returns whether the key was found.\n-   `delete(value)`: (List, Set, SortedSet) deletes a value.  Returns\n    whether the value was found.\n-   `find(value, opt_equals)`: (List, SortedSet, Array+) finds a value.\n    For List and SortedSet, returns the node at which the value was\n    found.  For SortedSet, the optional `equals` argument is ignored.\n-   `findLast(value, opt_equals)`: (List, Array+) finds the last\n    equivalent value, returning the node at which the value was found.\n-   `findLeast()`: (SortedSet) finds the smallest value, returning the\n    node at which it was found, or undefined.  This is fast\n    (logarithmic) and performs no rotations.\n-   `findLeastGreaterThan(value)`: (SortedSet) finds the smallest value\n    greater than the given value.  This is fast (logarithic) but does\n    cause rotations.\n-   `findLeastGreaterThanOrEqual(value)`: (SortedSet) finds the smallest\n    value greater than or equal to the given value.  This is fast\n    (logarithmic) but does cause rotations.\n-   `findGreatest()`: (SortedSet)\n-   `findGreatestLessThan(value)`: (SortedSet)\n-   `findGreatestLessThanOrEqual(value)`: (SortedSet)\n-   `push(...values)`: (Array, List)\n-   `pop()`: (Array, List)\n-   `shift()`: (Array, List)\n-   `unshift(...values)`: (Array, List)\n-   `slice(start, end)`: (Array, List) returns an array of the values\n    contained in the half-open interval [start, end), that is, including\n    the start and excluding the end.  For lists and arrays, both terms\n    may be numeric positive or negative indicies.  For a list, either\n    term may be a node.\n-   `splice(start, length, ...values)`: (Array, List) Works as with an\n    array, but for a list, the start may be an index or a node.\n-   `swap(start, length, values)`: (List, Array+) performs a splice\n    without variadic arguments.\n-   `wipe()`: (List, Set, Map, SortedSet, SortedMap, Array+, Object+)\n    Deletes the all values.\n-   `sort(opt_compare)`: (Array) sorts a collection in place.  The\n    comparator by only be a function.  The default comparator coerces\n    unlike types rather than fail to compare.\n-   `sorted(opt_compare, opt_by, opt_order)`: (List, Set, Map,\n    SortedSet, SortedMap, Array+) returns a sorted version of the\n    collection as an array.  Of map-like objects, only the values are\n    produced.  Accepts an optional comparator, relation, and order.  The\n    comparator may be a function that compares two arguments returning a\n    number relative to zero indicating the direction of the comparison,\n    where zero means either equal or incomparable.  The comparator may\n    alternately be an object with `{compare, by}` properties.  The\n    default comparator is `Object.compare` if shimmed by the `object`\n    module, or the simple `compare` function provided by the `operators`\n    module which delegates polymorphically to `compare` methods of\n    either operand, or falls back to `>` and `<` but only for like\n    types.  The `by` relation returns a mapped value for a value in the\n    collection on by which to compare values.  `sorted` uses the `by` to\n    compute the mapping exactly once, instead of once or twice as can\n    happen in the course of sorting.  The optional order property can be\n    specified as `-1` for descending order, defaults to `1` for\n    ascending, and `0` results in a stable sort, changing nothing.\n-   `reverse()`: (Array, List) reverses a collection in place.\n-   `reversed()`: (Array, List) returns a collection of the same type\n    with this collection's contents in reverse order.\n-   `concat(...iterables)`: (Array, Iterator, List, Set, Map, SortedSet,\n    SortedMap) Produces a new collection of the same type containing all\n    the values of itself and the values of any number of other\n    collections.  Favors the last of duplicate values.  For map-like\n    objects, the given iterables are treated as map-like objects and\n    each successively updates the result.  Array is like a map from\n    index to value.  List, Set, and SortedSet are like maps from nodes\n    to values.\n-   `keys()`: (Map, SortedMap, Object) returns an array of the keys\n-   `values()`: (Map, SortedMap, Object+) returns an array of the values\n-   `items()`: (Map, SortedMap, Object) returns an array of `[key, value]`\n    pairs for each item\n-   `reduce(callback(result, value, key, object, depth), basis, thisp)`:\n    (Array, Iterator, List, Set, Map, SortedSet, SortedMap)\n-   `reduceRight(callback(result, value, key, object, depth), basis,\n    thisp)`: (Array, List, Map, SortedSet, SortedMap)\n-   `forEach(callback(value, key, object, depth), thisp)`: (Array,\n    Iterator, List, Set, Map, SortedSet, SortedMap, Object+) calls the\n    callback for each value in the collection.  The iteration of lists\n    is resilient to changes to the list.  Particularly, nodes added\n    after the current node will be visited and nodes added before the\n    current node will be ignored, and no node will be visited twice.\n-   `map(callback(value, key, object, depth), thisp)`: (Array, Iterator,\n    List, Set, Map, SortedSet, SortedMap, Object+)\n-   `toArray()`: (Iterator, List, Set, Map, SortedSet, SortedMap,\n    Array+)\n-   `toObject()`: (Iterator, Map, SortedMap, Array+) converts any\n    collection to an object, treating this collection as a map-like\n    object.  Array is like a map from index to value.\n-   `filter(callback(value, key, object, depth), thisp)`: (Array, List,\n    Set, Map, SortedSet, SortedMap)\n-   `every(callback(value, key, object, depth), thisp)`: (Array,\n    Iterator, List, Set, Map, SortedSet, SortedMap) whether every value\n    passes a given guard.  Stops evaluating the guard after the first\n    failure.  Iterators stop consuming after the the first failure.\n-   `some(callback(value, key, object, depth), thisp)`: (Array, List,\n    Set, Map, SortedSet, SortedMap) whether there is a value that passes\n    a given guard.  Stops evaluating the guard after the first success.\n    Iterators stop consuming after the first success.\n-   `any()`: (Iterator, List, Set, Map, SortedSet, SortedMap, Array+)\n    whether any value is truthy\n-   `all()`: (Iterator, List, Set, Map, SortedSet, SortedMap, Array+)\n    whether all values are truthy\n-   `min()`: (Iterator, List, Set, Map, SortedSet, SortedMap, Array+)\n    the smallest value.  This is fast for sorted collections\n    (logarithic), but slow for everything else (linear).\n-   `max()`: (Iterator, List, Set, Map, SortedSet, SortedMap, Array+)\n    the largest value.  This is fast for sorted collections\n    (logarithic), but slow for everything else (linear).\n-   `one()`: (List, SortedSet, Array+) any single value, or throws an\n    exception if there are no values.  This is very fast (constant) for\n    all collections.  For a sorted set, the value is not deterministic.\n-   `only()`: (List, SortedSet, Array+) the one and only value, or\n    throws an exception if there are no values or more than one value.\n-   `count()`: (List, Set, Map, SortedSet, SortedMap, Array+)\n-   `sum()`: (Iterator, List, Set, Map, SortedSet, SortedMap, Array+)\n-   `average()`: (Iterator, List, Set, Map, SortedSet, SortedMap,\n    Array+)\n-   `flatten()`: (Iterator, List, Set, Map, SortedSet, SortedMap,\n    Array+)\n-   `zip(...collections)`: (List, Set, Map, SortedSet, SortedMap,\n    Array+)\n-   `enuemrate(zero)`: (Iterator, TODO List, Set, Map, SortedSet,\n    SortedMap, Array+)\n-   `sorted(compare)`: (List, Set, Map, Array+)\n-   `clone(depth, memo)`: (List, Set, Map, SortedSet, SortedMap, Array+,\n    Object+)\n    replicates the collection.  If `Object.clone` is shimmed, clones the\n    values deeply, to the specified depth, using the given memo to\n    resolve reference cycles (which must the `has` and `set` parts of\n    the Map interface, allowing objects for keys)\n-   `constructClone(values)`: (Iterator, List, Set, Map, SortedSet,\n    SortedMap, Array+) replicates a collection shallowly.  This is used\n    by each `clone` implementation to create a new collection of the\n    same type, with the same options (`equals`, `compare`, `hash`\n    options), but it leaves the job of deeply cloning the values to the\n    more general `clone` method.\n-   `equals(that)`: (List, Set, Array+, TODO SortedSet, Map, SortedMap)\n-   `compare(that)`: (Object+, TODO)\n-   `iterate()`: (List, Set, SortedSet, SortedMap, Array+)\n    Produces an iterator with a `next` method.  You may elect to get\n    richer iterators by wrapping this iterator with an `Iterator` from\n    the `iterator` module.  Iteration order of lists is resilient to\n    changes to the list.\n-   `iterate(start, end)`: (Array+) returns an iterator for all values\n    at indicies in the half-open interval [start, end), that is, greater\n    than start, and less than end.\n-   `iterate(start, end)`: (SortedSet) returns an iterator for all\n    values in the half-open interval [start, end), that is, greater than\n    start, and less than end.  The iterator is resilient against changes\n    to the data.\n-   `log(charmap, stringify)`: (Set, Map, SortedSet) writes a tree\n    describing the internal state of the data structure to the console.\n-   `splay(value)`: (SortedSet) rotates the internal splay tree such\n    that the root node is less than or equal to the given value.\n\n\n### Iterator\n\n-   `dropWhile(callback(value, index, iterator), thisp)`\n-   `takeWhile(callback(value, index, iterator), thisp)`\n-   `mapIterator(callback(value, index, iterator))`: (Iterator) returns\n    an iterator for a mapping on the source values.  Values are consumed\n    on demand.\n-   `filterIterator(callback(value, index, iterator))`: (Iterator) returns\n    an iterator for those values from the source that pass the given\n    guard.  Values are consumed on demand.\n\n\n### Iterator utilities\n\n-   `cycle(iterable, times)`\n-   `concat(iterables)`\n-   `transpose(iterables)`\n-   `zip(...iterables)`: variadic transpose\n-   `chain(...iterables)`: variadic concat\n-   `range(start, stop, step)`: iterates from start to stop by step\n-   `count(start, step)`: iterates from start by step, indefinitely\n-   `repeat(value, times)`: repeats the given value either finite times\n    or indefinitely\n\n\n### Observables\n\n`List`, `Set`, and `SortedSet` can be observed for content changes.\n\nA content change handler can have various forms.  The simplest form is a\nfunction that accepts `plus`, `minus`, and `index` as arguments where\n`plus` is an array of added values, `minus` is an array of deleted\nvalues, and `index` is the position of the change or undefined.  In that\ncase, `this` will be the collection that dispatches the event.\n\nAlternately, you can dispatch events to a handler object.  If the\nhandler has a `handleContentChange` function (for noticing a change\nafter it has occurred) or a `handleContentWillChange` function (for\nnoticing a change before it has occurred), the event will be dispatched\nto one of those.  The function has the same `(plus, minus, index)`\nsignature.\n\nYou can also dispatch change events to a DOM-compatible\n`handleEvent(event)` method, in which case the handler will receive an\nevent with `phase`, `currentTarget`, `target`, `plus`, `minus`, and\n`index` properties.  `phase` is either `\"before\"` or `\"after\"`.  The\ntargets are both the collection in flux.\n\n-   `(plus, minus, index)`\n-   `handleContentChange(plus, minus, index)`\n-   `handleContentWillChange(plus, minus, index)`\n-   `handleEvent({phase, currentTarget, target, plus, minus, index})`\n\nThe methods of the collection for managing content changes are generic,\nin the `observable` module, and have the following forms:\n\n-   `addContentChangeListener(listener, beforeChange)`\n-   `removeContentChangeListener(listener, beforeChange)`\n-   `dispatchContentChange(plus, minus, index)`\n-   `addBeforeContentChangeListener(listener)`\n-   `removeBeforeContentChangeListener(listener)`\n-   `dispatchBeforeContentChange(plus, minus, index)`\n-   `getContentChangeDescriptor()`\n\n\n## List\n\nLists are backed by a cyclic doubly-linked list with a head node.  The\nnodes are returned by \"find\" methods and accepted by \"slice\" and\n\"splice\" as representatives of positions within the list.  Their\nproperties and methods are part of the interface of the structure.\n\n-   `prev`: the previous node, or the `head` of the list if this is the\n    first node\n-   `next`: the next node, or the `head` of the list if this is the last\n    node\n\n\n## Set and Map\n\nSet and map are like hash tables, but not implemented with a block of\nmemory as they would be in a lower-level language.  Most of the work of\nproviding fast insertion and lookup based on a hash is performed by the\nunderlying plain JavaScript object.  Each key of the object is a hash\nstring and each value is a List of values with that hash.  The inner\nlist resolves collisions.  With a good `hash` method, the use of the\nlist can be avoided.\n\nSets and maps both have a `log` function that displays the internal\nstructure of the bucket list in an NPM-style.\n\n```\n┣━┳ 1\n┃ ┗━━ {\"key\":1,\"value\":\"a\"}\n┣━┳ 2\n┃ ┣━━ {\"key\":2,\"value\":\"c\"}\n┃ ┗━━ {\"key\":2,\"value\":\"d\"}\n┗━┳ 3\n  ┗━━ {\"key\":3,\"value\":\"b\"}\n```\n\n\n## Sorted Set and Sorted Map\n\nA binary splay tree is a balanced binary tree that rotates the most\nfrequently used items toward the root such that they can be accessed the\nmost quickly.  `sorted-set` and `sorted-map` are backed by a splay tree.\n\nAll map implementations use an underlying set implementation.  Any map\ncan be implemented trivially atop a set by wrapping `compare`, `equals`,\nor `hash` to operate on the key of an item.\n\nThe sorted set has a `root` node.  Each node has a `left` and `right`\nproperty, which may be null.  Nodes are returned by all of the \"find\"\nfunctions, and provided as the `key` argument to callbacks.\n\nBoth `sorted-set` and `sorted-map` implement a `log` function which can\nproduce NPM-style visualizations of the internal state of the sorted\ntree.\n\n```\n> set.log(SortedSet.ascii)\n  .-+ -3\n  | '-- -2\n.-+ -1\n+ 0\n| .-- 1\n'-+ 2\n  '-- 3\n```\n\n```\n> set.log(SortedSet.unicodeRound)\n  ╭━┳ -3\n  ┃ ╰━━ -2\n╭━┻ -1\n╋ 0\n┃ ╭━┳ 1\n┃ ┃ ╰━━ 2\n╰━┻ 3\n```\n\n## Map and SortedMap\n\nMaps share most of their implementation through `abstract-map`,\ndelegating to an `itemSet` property and overriding their operators to\nfollow the `key` property of each item in the set.  The set does most of\nthe work.\n\n\n## Object Shim\n\nThe collection methods on the `Object` constructor all polymorphically\ndefer to the corresponding method of any object that implements the\nmethod of the same name.  So, `Object.has` can be used to check whether\na key exists on an object, or in any collection that implements `has`.\nThis permits the `Object` interface to be agnostic of the input type.\n\nThe `object` module additionally provides an `Object.empty` frozen\nobject that can be reused as a default empty object to reduce\nunnecessary allocations.\n\n`Object.isObject(value)` tests whether it is safe to attempt to access\nproperties of a given value.\n\n`Object.is(a, b)` compares objects for exact identity and is a good\nalternative to `Object.equals` in many collections.\n\n`Object.getValueOf(value)` safely and idempotently returns the value of\nan object or value by only calling the `valueOf()` if the value\nimplements that method.\n\n`Object.owns` is a shorthand for `Object.prototype.hasOwnProperty.call`.\n\n\n## Coupling\n\nThese collections strive to maximize overlapping implementations where\npossible, but also be as loosely coupled as possible so developers only\npay for the features they need in the cost of download or execution\ntime.\n\nFor example, the default operators are simple, but much more powerful\noperators can be shimmed, enhancing all of the collections.\n\nAlso, collections supply a `clone` method, but it can only do shallow\nclones unless you shim `Object.clone` with the `object` module.\n`Object.clone` works fine by itself, but can only resolve reference\ncycles if you provide a map (WeakMap or Map) as its `memo` argument.\n\nAnother example, every collection provides an `iterate` implementation,\nbut each is only obligated to return an iterator that implements `next`.\nFor a much richer iterator, you can buy the `iterator` module and use\n`Iterate(collection)` to get a much richer interface.\n\n\n## References\n\n- a SplayTree impementation buried in Fedor Indutny’s super-secret\n  [Callgrind](https://github.com/indutny/callgrind.js). This\n  implementation uses parent references.\n- a SplayTree implementation adapted by [Paolo\n  Fragomeni](https://github.com/hij1nx/forest) from the V8 project and\n  based on the top-down splaying algorithm from \"Self-adjusting Binary\n  Search Trees\" by Sleator and Tarjan. This does not use or require\n  parent references, so I favored it over Fedor Indutny’s style.\n- the interface of ECMAScript harmony [simple maps and\n  sets](http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets)\n- a SplayTree implementation from [JavaScript data\n  structures](derrickburns/Javascript-Data-Structures) mainted by\n  Derrick Burns that supports change-resilient iterators and a\n  comprehensive set of introspection functions.\n\n## Future work\n\nGoals\n\n- tests\n- docs\n- shallow change dispatch and listeners for all collections (needed:\n  List, Set, SortedSet)\n- optional new on constructors\n- object shim for defineProperties\n- track indicies in sorted set\n- remove iterator dependency of Set\n\nMore methods\n\n- equals\n- compare\n- fast list splicing\n- set intersection, union, difference, symmetric difference\n\nMore possible collections\n\n- lru-set (least recently used cache)\n- lru-map\n- arc-set (adaptive replacement cache)\n- arc-map\n- sorted-list (sorted, can contain duplicates, perhaps backed by splay\n  tree with relaxation on the uniqueness invariant)\n- sorted-multi-map (sorted, can contain duplicate entries, perhaps\n  backed by sorted-list)\n- multi-map (unordered, can contain duplicates)\n- ordered-set (preserves traversal order based on insertion, unique\n  values)\n- ordered-map (preserves traversal order based on insertion, unique\n  keys)\n- ordered-multi-map (preserves traversal order based on insertion, may\n  contain duplicate keys)\n- string-set (set of strings, backed by a trie)\n- dict (string-map, map of strings to values, backed by a string set)\n- immutable-* (mutation functions return new objects that largely share\n  the previous version's internal state, some perhaps backed by a hash\n  trie)\n- array heap implementation\n- binary heap implementation\n\n",
  "_id": "collections@0.0.7",
  "_from": "collections@>=0.0.6"
}
